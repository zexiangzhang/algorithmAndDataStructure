# 一个三角形的数字堆， 找出一条从三角形顶端到底端的路径，使得路径上的各数字之和最大。求最大之和。  
# 要求： 只能向左右下角移动。  
# 输入： 总共有n层（1<n<100）, 数字为0-99

# 人人为我， 向上递推
n = 20
nums = [
    [5],
    [1, 6],
    [9, 2, 4],
    [1, 6, 4, 5],
    [6, 4, 6, 3, 4],
    [6, 5, 3, 3, 4, 9],
    [2, 4, 6, 3, 4, 3, 5],
    [2, 2, 5, 3, 4, 3, 5, 3],
    [6, 9, 3, 3, 7, 9, 9, 0, 5],
    [1, 4, 7, 9, 3, 3, 9, 6, 5, 6],
    [4, 2, 3, 3, 2, 4, 3, 6, 5, 6, 2],
    [1, 8, 2, 4, 3, 3, 9, 6, 2, 1, 9, 1],
    [9, 4, 3, 3, 6, 4, 2, 5, 5, 6, 2, 3, 8],
    [1, 3, 8, 6, 3, 3, 9, 2, 7, 7, 4, 5, 7, 1],
    [9, 4, 3, 3, 9, 7, 1, 6, 5, 6, 3, 7, 2, 7, 4],
    [4, 2, 3, 3, 9, 7, 1, 6, 5, 6, 3, 7, 2, 7, 4, 5],
    [9, 4, 3, 4, 3, 3, 9, 6, 2, 6, 3, 7, 2, 7, 4, 3, 7],
    [9, 4, 3, 3, 9, 7, 1, 6, 5, 6, 3, 7, 2, 7, 4, 1, 7, 2],
    [9, 4, 3, 3, 9, 7, 1, 6, 5, 6, 3, 7, 2, 7, 4, 8, 2, 1, 3],
    [9, 3, 8, 6, 3, 3, 9, 2, 7, 6, 3, 7, 2, 7, 4, 7, 1, 3, 6, 9],
]

# 动态规划
max_nums = [[0 for _ in range(0, i)] for i in range(1, n + 1)]

for j in range(0, n):
    max_nums[n - 1][j] = nums[n - 1][j]

for i in range(n - 2, -1, -1):
    for k in range(0, i + 1):
        max_nums[i][k] = max(max_nums[i + 1][k],
                             max_nums[i + 1][k + 1]) + nums[i][k]

print(max_nums[0][0])  # n(n-1)/2


# 空间优化
for i in range(n - 2, -1, -1):
    for k in range(0, i + 1):
        nums[i][k] = max(nums[i + 1][k], nums[i + 1][k + 1]) + nums[i][k]

print(nums[0][0])
